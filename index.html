<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transcriptio Linguae</title>
  <style>
    html {
      font-size: 16px;
    }

    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 2rem auto;
      padding: 0 3rem;
      color: #2c3e50;
      background: #ffffff;
      line-height: 1.6;
      font-size: 1rem;
    }

    h1 {
      font-family: "Times New Roman", Times, serif;
      text-align: center;
      color: #34495e;
      margin: 0 0 0.5rem 0;
      font-weight: 700;
    }

    h3 {
      font-family: Arial, sans-serif;
      text-align: center;
      font-weight: 500;
      color: #7f8c8d;
      margin-bottom: 2rem;
    }

    textarea, pre {
      font-family: Arial, sans-serif;
      font-size: 1rem;
      line-height: 1.5;
    }

    textarea {
      width: 100%;
      min-height: 6em;
      padding: 0.75em 1em;
      border: 1.5px solid #ccc;
      border-radius: 6px;
      resize: vertical;
      box-sizing: border-box;
      transition: border-color 0.3s ease;
    }

    textarea:focus {
      outline: none;
      border: 1.5px solid #ccc;
      box-shadow: none;
    }

    textarea::placeholder {
      color: grey;
      user-select: none;
    }

    pre {
      background: #ecf0f1;
      padding: 1.25rem 1.5rem;
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-word;
      margin-top: 2rem;
      box-shadow: inset 0 0 5px #dfe6e9;
    }

    /* Placeholder style for output field */
    pre.placeholder {
      color: grey;
      user-select: none;
    }

    pre:not(.placeholder) {
      color: #2c3e50;
      user-select: text;
    }

    button {
      font-family: Arial, sans-serif;
      background: #909599;
      color: #ffffff;
      border: none;
      border-radius: 6px;
      padding: 0.65em 1.4em;
      font-size: 1rem;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.25s ease;
      margin-right: 1rem;
      margin-bottom: 2px;
    }

    button:hover,
    button:focus {
      background: #abb1b4;
      outline: none;
    }

    button:disabled {
      background: #ecf0f1;
      cursor: not-allowed;
    }

    @media (max-width: 600px) {
      textarea, pre {
        font-size: 1.1rem;
      }
    }
  </style>
</head>
<body>
  <h1>Transcriptio Linguae</h1>
  <h3>Italiano → AFI Trascrizione</h3>

  <textarea id="input" rows="6" cols="60" placeholder="Inserisci testo in italiano"></textarea><br />
  <button id="convert">AFI</button>
  <button id="convertInline">Testo e AFI</button>
  <button id="convertG2P">G2P</button>
  <pre id="output" class="placeholder">Trascrizione</pre>

  <script type="module">
    import initESpeak from './espeak-ng.js';

    const outputElem = document.getElementById('output');
    const inputElem = document.getElementById('input');

    let wasmReady = false;

    window.addEventListener('load', async () => {
      try {
        await initESpeak({
          print: () => {},
          printErr: () => {}
        });
        wasmReady = true;
        console.log('eSpeak NG WASM loaded and ready');
      } catch (e) {
        console.error('Error loading WASM:', e);
        outputElem.classList.remove('placeholder');
        outputElem.innerText = 'Error loading eSpeak WASM module.';
      }
    });

    function printErrFiltered(err) {
      if (
        err.includes('still waiting on run dependencies') ||
        err.includes('dependency: wasm-instantiate') ||
        err.includes('(end of list)')
      ) {
        return;
      }
      console.error('eSpeak stderr:', err);
    }

    async function runESpeak(text) {
      let ipaOutput = '';
      await initESpeak({
        arguments: ['-v', 'it', '--ipa=3', text],
        print: (text) => {
          ipaOutput += text;
        },
        printErr: printErrFiltered
      });

      return ipaOutput
        .replace(/rɾ/g, 'rː')
        .replace(/mm/g, 'mː')
        .replace(/ff/g, 'fː')
        .replace(/vv/g, 'vː')
        .replace(/ll/g, 'lː')
        .replace(/kk/g, 'kː')
        .replace(/nn/g, 'nː')
        .replace(/ɲɲ/g, 'ɲː')
        .replace(/s\u200Ds/g, 'sː')
        .replace(/ss/g, 'sː')
        .replace(/t\u200D/g, 't')
        .replace(/d\u200D/g, 'd')
        .replace(/ɾ/g, 'r')
        .replace(/oo/g, 'oː')
        .trim();
    }

    function showPlaceholder() {
      outputElem.className = 'placeholder';
      outputElem.innerText = 'Trascrizione';
    }

    function showProgressPlaceholder() {
      outputElem.className = 'placeholder';
      outputElem.innerText = 'Trascrizione in corso...';
    }

    function setOutput(text) {
      outputElem.classList.remove('placeholder');
      outputElem.innerText = text;
    }

    // Grapheme-to-Phoneme mapping function based on the IPA and original text tokens
    // Rule: if in IPA transcription there is 'tʃ' followed immediately by 'i',
    // then map 'tʃ' as (tʃ) attached to C only (C(tʃ))
    // else if IPA does NOT have 'i' after 'tʃ' but original text has 'i' after 'C',
    // then map 'Ci(tʃ)' instead.

    function g2pMapping(originalWord, ipaTranscription) {
      // We'll process the original word and ipa transcription character by character,
      // For demo: just apply the rule on the first 'C' and 'tʃ'

      // Find index of 'C' in originalWord (should be first letter or wherever)
      const cIndex = originalWord.indexOf('C');
      if (cIndex === -1) return originalWord; // no C, return original

      // Find 'tʃ' in ipaTranscription
      const tʃIndex = ipaTranscription.indexOf('tʃ');
      if (tʃIndex === -1) {
        // no tʃ in IPA, return original word as-is
        return originalWord;
      }

      // Check if there is 'i' immediately after 'tʃ' in IPA
      const ipaHasIAfter_tʃ = ipaTranscription[tʃIndex + 2] === 'i';

      // Check if original text has 'i' after C
      const origHasIAfterC = originalWord[cIndex + 1] === 'i';

      if (ipaHasIAfter_tʃ) {
        // Map tʃ as C(tʃ)
        // For example: Ciao → C(tʃ)iao
        // So replace C with C(tʃ)
        return (
          originalWord.slice(0, cIndex) +
          'C(tʃ)' +
          originalWord.slice(cIndex + 1)
        );
      } else if (!ipaHasIAfter_tʃ && origHasIAfterC) {
        // Map as Ci(tʃ)
        // Replace 'Ci' with 'Ci(tʃ)'
        if (
          originalWord[cIndex] === 'C' &&
          originalWord[cIndex + 1] === 'i'
        ) {
          return (
            originalWord.slice(0, cIndex) +
            'Ci(tʃ)' +
            originalWord.slice(cIndex + 2)
          );
        }
      }

      // Otherwise, fallback to original word
      return originalWord;
    }

    window.addEventListener('DOMContentLoaded', () => {

      document.getElementById('convertInline').addEventListener('click', async () => {
        showProgressPlaceholder();

        if (!wasmReady) {
          alert('Please wait, WASM is still loading...');
          return;
        }

        const rawInput = inputElem.value.trim();
        if (!rawInput) {
          showPlaceholder();
          return;
        }

        const tokens = rawInput.match(/[A-Za-zÀ-ÖØ-öø-ÿĀ-žḀ-ỿ]+|[0-9]+(?:[.,][0-9]+)?|[^\s]/gu);
        if (!tokens) {
          setOutput('[No valid input]');
          return;
        }

        const ipaMap = new Map();

        const uniqueWords = [...new Set(
          tokens.filter(t =>
            /^[A-Za-zÀ-ÖØ-öø-ÿĀ-žḀ-ỿ]+$/u.test(t)
          )
        )];

        try {
          for (const word of uniqueWords) {
            const ipa = await runESpeak(word);
            ipaMap.set(word, ipa);
          }
        } catch (e) {
          console.error('Error during IPA conversion:', e);
        }

        const result = [];
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];

          const isWord = /^[A-Za-zÀ-ÖØ-öø-ÿĀ-žḀ-ỿ]+$/u.test(token);
          const isNumber = /^[0-9]+(?:[.,][0-9]+)?$/.test(token);

          if (i > 0) {
            const prev = tokens[i - 1];
            if (
              !(token === ')' || token === ',' || token === '.' || token === ';' || token === ':' || token === '!' || token === '?') &&
              !(prev === '(')
            ) {
              result.push(' ');
            }
          }

          if (isWord) {
            const ipa = ipaMap.get(token) || '';
            result.push(`${token} (${ipa})`);
          } else {
            result.push(token);
          }
        }

        setOutput(result.join(''));
      });

      document.getElementById('convert').addEventListener('click', async () => {
        showPlaceholder();

        if (!wasmReady) {
          alert('Please wait, WASM is still loading...');
          return;
        }

        const rawInput = inputElem.value.trim();
        if (!rawInput) {
          showPlaceholder();
          return;
        }

        const markedInput = rawInput.replace(/\s+/g, '|');

        try {
          const ipa = await runESpeak(markedInput);
          setOutput(ipa.replace(/\|/g, ' ') || '[No output generated]');
        } catch (e) {
          setOutput('Error during transcription: ' + e.message);
        }
      });

      // New G2P button
      document.getElementById('convertG2P').addEventListener('click', async () => {
        showProgressPlaceholder();

        if (!wasmReady) {
          alert('Please wait, WASM is still loading...');
          return;
        }

        const rawInput = inputElem.value.trim();
        if (!rawInput) {
          showPlaceholder();
          return;
        }

        const tokens = rawInput.match(/[A-Za-zÀ-ÖØ-öø-ÿĀ-žḀ-ỿ]+|[0-9]+(?:[.,][0-9]+)?|[^\s]/gu);
        if (!tokens) {
          setOutput('[No valid input]');
          return;
        }

        const ipaMap = new Map();

        const uniqueWords = [...new Set(
          tokens.filter(t =>
            /^[A-Za-zÀ-ÖØ-öø-ÿĀ-žḀ-ỿ]+$/u.test(t)
          )
        )];

        try {
          for (const word of uniqueWords) {
            const ipa = await runESpeak(word);
            ipaMap.set(word, ipa);
          }
        } catch (e) {
          console.error('Error during IPA conversion:', e);
        }

        const result = [];
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];

          const isWord = /^[A-Za-zÀ-ÖØ-öø-ÿĀ-žḀ-ỿ]+$/u.test(token);
          const isNumber = /^[0-9]+(?:[.,][0-9]+)?$/.test(token);

          if (i > 0) {
            const prev = tokens[i - 1];
            if (
              !(token === ')' || token === ',' || token === '.' || token === ';' || token === ':' || token === '!' || token === '?') &&
              !(prev === '(')
            ) {
              result.push(' ');
            }
          }

          if (isWord) {
            const ipa = ipaMap.get(token) || '';

            // Apply G2P mapping rule here
            const mapped = g2pMapping(token, ipa);

            // We want the output in form: Ci(tʃ)a(a)o(o) — which means
            // for demo purposes, map only the 'C' + 'tʃ' part, and then
            // append each grapheme with (phoneme) after it.

            // Let's build the final G2P string: each letter + (corresponding phoneme or letter)
            // For now, the rule only maps the special C/tʃ combo, so let's output that with the rest letters paired as (letter)
            // Except we keep original letter in the output.

            // For simplicity, let's build output like this:
            // mappedWord = example "Ci(tʃ)ao"
            // output = C(i)(tʃ)a(a)o(o)
            // So we insert phoneme in parenthesis if mapping applies, else letter in parenthesis.

            // To keep it simple, just output mapped word with added (phoneme) for the tʃ part:

            // Let's find where the (tʃ) appears in mapped word:
            let g2pOutput = '';
            for (let pos = 0; pos < mapped.length; pos++) {
              const char = mapped[pos];
              if (
                char === '(' &&
                mapped.slice(pos, pos + 4) === '(tʃ)'
              ) {
                // Attach (tʃ) to previous char (C or i)
                // Already included, so skip printing (tʃ) again
                continue;
              } else if (
                pos > 0 &&
                mapped.slice(pos - 1, pos + 3) === 'C(tʃ)'
              ) {
                // this case covered, skip
                continue;
              } else if (
                mapped.slice(pos, pos + 4) === '(tʃ)'
              ) {
                // skip printing (tʃ) alone because already attached
                continue;
              } else if (
                char.match(/[A-Za-zÀ-ÖØ-öø-ÿĀ-žḀ-ỿ]/)
              ) {
                // if next chars are (tʃ), skip the (tʃ) since it belongs to this char
                if (mapped.slice(pos, pos + 5) === 'C(tʃ)') {
                  g2pOutput += 'C(tʃ)';
                  pos += 4; // skip extra chars
                } else if (mapped.slice(pos, pos + 4) === 'i(tʃ)') {
                  g2pOutput += 'i(tʃ)';
                  pos += 4;
                } else {
                  g2pOutput += char + '(' + char + ')';
                }
              } else {
                // skip parentheses etc
                continue;
              }
            }

            // If the above is too complex, let's just output the mapped word + (phoneme) for each letter except special ones
            // For now, just output mapped word as-is (the main goal is to see the G2P mapping applied)

            result.push(g2pOutput || mapped);
          } else {
            result.push(token);
          }
        }

        setOutput(result.join(''));
      });
    });
  </script>
</body>
</html>
